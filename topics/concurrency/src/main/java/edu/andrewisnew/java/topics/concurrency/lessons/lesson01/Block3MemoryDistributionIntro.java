package edu.andrewisnew.java.topics.concurrency.lessons.lesson01;
/**
ПАМЯТЬ В JAVA

При запуске программы, под нее выделяется определенный объем памяти. Этот объем можно переопределить с помощью ключей.

Предположим выделено 128 mb.
JVM из этого объема часть заберет для хранения своей мета-информации.
Оставшаяся часть разделена между heap и non-heap (~ 9 к 1).
Non-heap делится на Method area и Native area.

До 8 версии java non-heap - PermGen.
Объем памяти был зафиксирован

После появился Metaspace, заменивший PermGen.
Metaspace увеличивается автоматически, и может забрать все (либо указанный предел)

Native area делтся на пул стеков, Compiled by jit code, native objects (objects created by native code)

В Method area добавляется информация каждый раз, когда загружается класс. Там для каждого класса находится свой фрейм.
При загрузке класса jvm идет в classpath, загружает класс файл. В Method area она выделяет блок памяти для хранения
информации об этом классе.
В каждом таком фрейме есть Runtime constant pool. Это таблица, в которой описаны все связи этого класса с остальными (ссылки на них).
Также во фрейме есть Field & Method data (говорит само за себя).
И последнее - байткод методов

Пул стеков это стеки в которых хранятся стэк фреймы и каждый поток обладает таким стэком.
Для каждогопотока хранится PC (program counter) - указатель на текущую исполняемую инструкцию в байткоде.
Также есть стэк и native стэк (native для работы с нативными методами, там есть набор методов, между которыми поток переключается).
В стэке хранятся стэк фреймы.
Стэк фрейм выделяется каждый раз, когда осуществляется заход в новый метод.
Стэк фрейм хранит:
    возвращаемое значение (к нему обращается вызывающий метод после того как вызываемый отработал)
    локальные переменные
    стэк операндов {@link Block4OperandStack}
    ссылка на текущий класс фрейм
 */
public class Block3MemoryDistributionIntro {
}
