Существуют слабая и сильная модели памяти. 
* В сильной все видят одинаковые значения, на что требуются дополнительные расходы
* В слабой имеются барьеры памяти
  * Существует инструкция на сброс данных (flush) - поделиться локалными данными со всеми
  * Инструкция на объявление данных недействительными (invalidate) - её можно применять как на свой, так и на чужой кэш
чтобы прочитать из invalidate блока, нужно его обновить


Данные в Java хранятся в 
* Регистрах
* Кэше
* Ram

Ввиду этого нужно поддерживать видимость изменений и бороться с гонкой потоков при чтении/записи общей памати

Также существует проблема reordering - комманды могут быть исполнены не в том порядке, в котором определены в исходном коде.

https://gee.cs.oswego.edu/dl/jmm/cookbook.html - полезная ссылка

**Видимость final полей** - действуют после корректного конструирования объекта
1. Значение, записанное в final поле видно всем потокам
2. Значения, достижимые из final поля не менее свежие, чем значение этого final поля

*действуют после корректного конструирования объекта* - если выбросили исключение из объекта, или в конструкторе передали this куда-то, то гарантий нет


**Happens before**

поток X выполняет операцию A, Y - операцию B

**A happens before B** - значит поток, выполняющий B будет видеть все изменения, выполненые потоком X до операции A, включая результат операции A

Happens before **транзитивно**

Happens before:
1. Освобождение монитора happens before захвата того же монитора
2. Lock.unlock() happens before Lock.lock() (tryLock())
3. Write to volatile happens before read from volatile
4. Завершение run() потока happens before join() на потоке, или возвращения false из isAlive() на потоке
5. Вызов метода interrupt() happens before поток обнаружил это:
   * Выбрасывая InterruptedException
   * Вызывая interrupted()/isInterrupted()
6. Успешное завершение конструктора happens before finalize()


Статические поля видны всем потокам после инициализации и гарантировано будут проинициализированы одним потоком